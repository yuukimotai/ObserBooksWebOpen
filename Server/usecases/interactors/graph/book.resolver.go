package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.39

import (
	"context"
	"fmt"
	"obserbooks/graph"
	"obserbooks/graph/model"
	repositories "obserbooks/infrastructure/repositories/book"
)

// CreateBook is the resolver for the createBook field.
func (r *mutationResolver) CreateBook(ctx context.Context, input model.NewBook) (*model.Book, error) {
	bi := NewBookInteractor(*repositories.NewBookRepository(r.DB))
	result, err := bi.bookRepository.CreateBook(ctx, input)
	println(result)

	book := &model.Book{
		Title:         result.Title,
		Author:        result.Author,
		JanCode:       result.JanCode,
		PublisherName: result.PublisherName,
	}

	return book, err
}

// UpdateBook is the resolver for the updateBook field.
func (r *mutationResolver) UpdateBook(ctx context.Context, input model.UpdateBook) (*model.Book, error) {
	validateResult, validateErr := ValidateJwt(ctx)
	if validateErr != nil {
		fmt.Println(validateResult, validateErr)
		return nil, validateErr
	}
	bi := NewBookInteractor(*repositories.NewBookRepository(r.DB))
	result, err := bi.bookRepository.UpdateBook(ctx, input)
	if err != nil {
		println(err)
	}

	book := &model.Book{
		Title:   result.Title,
		Author:  result.Author,
		JanCode: result.JanCode,
	}

	return book, nil
}

// DeleteBook is the resolver for the deleteBook field.
func (r *mutationResolver) DeleteBook(ctx context.Context, input model.DeleteBook) (*model.Book, error) {
	validateResult, validateErr := ValidateJwt(ctx)
	if validateErr != nil {
		fmt.Println(validateResult, validateErr)
		return nil, validateErr
	}
	bi := NewBookInteractor(*repositories.NewBookRepository(r.DB))
	result, err := bi.bookRepository.DeleteBook(ctx, input)
	if err != nil {
		println(err)
	}

	book := &model.Book{
		Title:         result.Title,
		Author:        result.Author,
		JanCode:       result.JanCode,
		PublisherName: result.PublisherName,
	}

	return book, nil
}

// FindAllMyBook is the resolver for the findAllMyBook field.
func (r *queryResolver) FindAllMyBook(ctx context.Context) ([]*model.Book, error) {
	bi := NewBookInteractor(*repositories.NewBookRepository(r.DB))
	result, err := bi.bookRepository.FindMyBooks(ctx)
	if err != nil {
		fmt.Println("bookRepositoryからレコードが取得できませんでした")
	}
	fmt.Println(result)
	books := []*model.Book{}
	for i := 0; i < len(result); i++ {
		book := &model.Book{
			Title:          result[i].Title,
			Author:         result[i].Author,
			JanCode:        result[i].JanCode,
			PublisherName:  result[i].PublisherName,
			ItemUrl:        result[i].ItemUrl,
			LargeImageUrl:  result[i].LargeImageUrl,
			MediumImageUrl: result[i].MediumImageUrl,
			MyBook:         result[i].MyBook,
			AttentionBook:  result[i].AttentionBook,
		}
		books = append(books, book)
	}

	return books, err
}

// FindBook is the resolver for the findBook field.
func (r *queryResolver) FindBook(ctx context.Context, input model.FindBook) (*model.Book, error) {
	validateResult, validateErr := ValidateJwt(ctx)
	if validateErr != nil {
		fmt.Println(validateResult, validateErr)
		return nil, validateErr
	}
	bi := NewBookInteractor(*repositories.NewBookRepository(r.DB))
	result, err := bi.bookRepository.FindBook(ctx, input)
	if err != nil {
		println(err)
	}

	book := &model.Book{
		Title:         result.Title,
		Author:        result.Author,
		JanCode:       result.JanCode,
		PublisherName: result.PublisherName,
	}

	return book, nil
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
